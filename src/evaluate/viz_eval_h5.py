#!/usr/bin/env python3
"""
viz_eval_h5.py

Headless visualization script for evaluation H5 files generated by test_eval_dataset.py.

Usage:
    python viz_eval_h5.py \
        --h5-path <path/to/output.h5> \
        --out-dir <path/to/viz> \
        --top-k 5 \
        --chunk-stride 10
"""

import argparse
from pathlib import Path
import numpy as np
import h5py
from tqdm import tqdm
import matplotlib
matplotlib.use("Agg")  # Force headless backend before importing pyplot
import matplotlib.pyplot as plt
from matplotlib.patches import Patch


def parse_args():
    """Parse command line arguments for the visualization script."""
    parser = argparse.ArgumentParser("Visualize evaluation H5 results (headless)")
    parser.add_argument("--h5-path", type=str, required=True, help="Path to H5 evaluation file")
    parser.add_argument("--out-dir", type=str, default="viz", help="Output directory for visualizations")
    parser.add_argument("--top-k", type=int, default=5, help="Number of worst episodes to visualize")
    parser.add_argument("--chunk-stride", type=int, default=1,
                        help="Stride for drawing action chunks (e.g., 10 draws chunks at steps 0,10,20,...)")
    return parser.parse_args()


def save_hist(data, path, title, xlabel, ylabel, bins=50):
    """Save histogram plot to file."""
    plt.figure(figsize=(6, 4))
    plt.hist(data, bins=bins)
    plt.xlabel(xlabel); plt.ylabel(ylabel); plt.title(title)
    plt.tight_layout(); plt.grid(True); plt.grid(True, linestyle='--', color='gray', alpha=0.5)
    plt.savefig(path, dpi=600); plt.close()


def save_curve(y, path, title, xlabel, ylabel):
    """Save line plot to file."""
    plt.figure(figsize=(6, 4))
    plt.plot(y)
    plt.xlabel(xlabel); plt.ylabel(ylabel); plt.title(title)
    plt.tight_layout(); plt.grid(True); plt.grid(True, linestyle='--', color='gray', alpha=0.5)
    plt.savefig(path, dpi=600); plt.close()


def main():
    """Main visualization pipeline for evaluation H5 files."""
    args = parse_args()
    h5_path = Path(args.h5_path)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Load episode-level summary statistics
    with h5py.File(h5_path, "r") as f:
        summary = f["episode_mse_summary"]
        episode_idx = summary["episode_idx"][:]
        mean_mse = summary["mean"][:]

    # Generate episode-level statistical visualizations
    save_hist(mean_mse, out_dir / "episode_mean_mse_hist.png",
              title="Episode-level Mean Action MSE Distribution",
              xlabel="Mean Action MSE", ylabel="Count")

    # Sort episodes by MSE (worst to best) and plot sorted curve
    order = np.argsort(mean_mse)[::-1]
    save_curve(mean_mse[order], out_dir / "episode_mean_mse_sorted.png",
               title="Episodes Sorted by Mean MSE",
               xlabel="Episode (sorted)", ylabel="Mean Action MSE")

    save_curve(mean_mse, out_dir / "episode_mean_mses.png",
               title="Episodes Mean MSE",
               xlabel="Episode Index", ylabel="Mean Action MSE")

    # Select top-K worst episodes for detailed visualization
    top_k = min(args.top_k, len(order))
    worst_eps = episode_idx[order[:top_k]]

    # Generate detailed visualizations for each worst episode
    with h5py.File(h5_path, "r") as f:
        for ep in tqdm(worst_eps, desc="Processing episodes", dynamic_ncols=True):
            ep_name = f"episode_{ep:06d}"
            grp = f[ep_name]

            # Load joint names if available
            joint_names = None
            if "action_joint_names" in grp:
                joint_names = [name.decode("utf-8") if isinstance(name, bytes) else str(name)
                             for name in grp["action_joint_names"][:]]
            else:
                raise KeyError(f"{ep_name} does not contain 'action_joint_names' dataset.")

            # Load episode data: step-wise MSE, predictions, and ground truth
            step_mse = grp["action_mse"][:]  # (T,) step-wise MSE values
            pred = grp["action"][:]          # (T, H, D) predicted action chunks
            gt = grp["gt_action"][:]         # (T, D) ground truth actions

            dt = 1.0  # Time step
            T, H, D = pred.shape  # T: time steps, H: horizon, D: action dimension

            # Calculate x-axis limits (rounded up to nearest multiple of 50)
            max_time = int(np.ceil(T / 50.0) * 50)
            T_cut = min(T, max_time)
            step_mse = step_mse[:T_cut]
            pred = pred[:T_cut]
            gt = gt[:T_cut]

            if joint_names is not None:
                assert len(joint_names) == D, f"Joint name count ({len(joint_names)}) mismatch"

            # Create multi-panel figure with one subplot per action dimension
            fig, axes = plt.subplots(D, 1, figsize=(14, max(4 * D, 10)),
                                     sharex=True, gridspec_kw={'hspace': 0.1})
            if D == 1:
                axes = [axes]  # Ensure axes is always a list

            colors = plt.cm.tab10(np.linspace(0, 1, max(D, 10)))
            fig_title = f"{ep_name} Action Chunks (stride={args.chunk_stride}) with GT + MSE"

            # Plot each action dimension in separate subplot
            for d in tqdm(range(D), desc=f"Processing joints for {ep_name}", leave=False):
                ax = axes[d]
                base_color = colors[d]
                subplot_handles = []  # Legend handles for this subplot
                subplot_labels = []   # Legend labels for this subplot

                # Draw predicted action chunks with strided sampling
                for i in range(0, T_cut, args.chunk_stride):
                    local_t = np.arange(H) * dt + i * dt
                    y = pred[i, :, d]
                    for k in range(H - 1):
                        # Apply fading effect along prediction horizon
                        frac = (k / max(1, H - 1)) ** 0.8
                        lw = 1.5 - 1.2 * frac
                        fade_color = base_color[:3] * (1 - frac) + frac
                        line = ax.plot(local_t[k:k+2], y[k:k+2], color=fade_color, linewidth=lw)
                        if i == 0 and k == 0:  # Add legend entry only once
                            subplot_handles.append(line[0])
                            subplot_labels.append("Predicted Chunks")

                # Plot ground truth trajectory
                gt_line = ax.plot(np.arange(T_cut) * dt, gt[:, d], color="black", linewidth=2.0)
                subplot_handles.append(gt_line[0])
                subplot_labels.append("Ground Truth")

                # Create secondary axis for MSE visualization (red, right side)
                ax2 = ax.twinx()
                t = np.arange(T_cut) * dt
                mse_fill = ax2.fill_between(t, step_mse, 0, color="red", alpha=0.12, zorder=0, linewidth=0)
                mse_patch = Patch(facecolor='red', alpha=0.12, label='Action MSE')
                subplot_handles.append(mse_patch)
                subplot_labels.append("Action MSE")

                # Configure MSE axis limits and appearance
                ax2.set_ylim(bottom=0)
                mse_nonzero = step_mse[step_mse > 0]
                if len(mse_nonzero) > 0:
                    mse_max = np.percentile(mse_nonzero, 95)  # Use 95th percentile to exclude outliers
                    ax2.set_ylim(0, max(mse_max * 1.1, 0.01))

                ax2.tick_params(axis="y", labelsize=8, colors="red")
                ax2.spines['right'].set_color('red')

                # Configure primary axis (left side, action values)
                joint_label = joint_names[d] if joint_names is not None else f"dim {d}"
                ax.set_ylabel(joint_label, fontsize=12)
                ax.grid(True, linewidth=0.3, alpha=0.5)

                # Add title only to first subplot
                if d == 0:
                    ax.set_title(fig_title, fontsize=15, pad=3)

                # Add legend to top-right corner of each subplot
                ax.legend(subplot_handles, subplot_labels, loc='upper right', fontsize=9, frameon=True,
                         fancybox=False, shadow=False, borderpad=0.2, handlelength=1.0,
                         handletextpad=0.3, labelspacing=0.2)

            # Configure shared x-axis with step numbers
            axes[-1].set_xlabel("Step", fontsize=12)

            # Set x-axis limits to rounded-up value (e.g., 160 -> 200)
            axes[-1].set_xlim(0, max_time)

            # Calculate x-axis ticks with step numbers
            # Determine tick spacing based on max_time
            if max_time <= 100:
                tick_spacing = 20
            elif max_time <= 200:
                tick_spacing = 40
            elif max_time <= 500:
                tick_spacing = 100
            else:
                tick_spacing = 200

            # Generate tick positions
            x_ticks = np.arange(0, max_time + 1, tick_spacing)
            # Ensure max_time is included if not already
            if max_time not in x_ticks:
                x_ticks = np.append(x_ticks, max_time)
            # Ensure 0 is included
            if 0 not in x_ticks:
                x_ticks = np.append(0, x_ticks)
            x_ticks = np.sort(x_ticks)

            # IMPORTANT: Enable x-axis ticks and labels on all axes
            for i, ax in enumerate(axes):
                # Set ticks and tick labels
                ax.set_xticks(x_ticks)
                ax.set_xticklabels([str(int(tick)) for tick in x_ticks], fontsize=9)
                # Ensure bottom spine is visible
                ax.spines['bottom'].set_visible(True)
                # Ensure tick labels are visible (not clipped)
                ax.tick_params(axis='x', which='both', labelsize=9, length=4, width=1)
                # Only show x-axis label on the bottom subplot
                if i != len(axes) - 1:
                    ax.tick_params(axis='x', labelbottom=True)  # Show tick labels on all subplots
                    ax.set_xlabel('')  # Remove x-label from upper subplots

            # Adjust layout with more bottom space for x-axis labels
            fig.subplots_adjust(top=0.95 if D == 1 else 0.97, bottom=0.12, left=0.08, right=0.92, hspace=0.08)
            fig.savefig(out_dir / f"{ep_name}_all_joints_full_chunk.png", dpi=200, bbox_inches='tight')
            plt.close(fig)

    print(f"[Done] Visualization results saved to: {out_dir.resolve()}")


if __name__ == "__main__":
    main()
