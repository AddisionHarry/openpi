#!/usr/bin/env python3
"""
viz_eval_h5.py

Headless visualization script for evaluation H5 files generated by test_eval_dataset.py.

Usage:
    python viz_eval_h5.py \
        --h5-path <path/to/output.h5> \
        --out-dir <path/to/viz> \
        --top-k 5 \
        --chunk-stride 10
"""

import argparse
from pathlib import Path
import numpy as np
import h5py
from tqdm import tqdm
import matplotlib
matplotlib.use("Agg")  # Force headless backend before importing pyplot
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.patches import Patch
from matplotlib.collections import LineCollection


def parse_args():
    """Parse command line arguments for the visualization script."""
    parser = argparse.ArgumentParser("Visualize evaluation H5 results (headless)")
    parser.add_argument("--h5-path", type=str, required=True, help="Path to H5 evaluation file")
    parser.add_argument("--out-dir", type=str, default="viz", help="Output directory for visualizations")
    parser.add_argument("--top-k", type=int, default=5, help="Number of worst episodes to visualize")
    parser.add_argument("--chunk-stride", type=int, default=1,
                        help="Stride for drawing action chunks (e.g., 10 draws chunks at steps 0,10,20,...)")
    # parser.add_argument("--resample-k", type=int, default=5, help="Number of worst episodes to visualize")
    return parser.parse_args()


def save_hist(data, path, title, xlabel, ylabel, bins=50):
    """Save histogram plot with mode annotated."""
    plt.figure(figsize=(6, 4))
    counts, edges, _ = plt.hist(data, bins=bins, color='steelblue', edgecolor='black')
    mode_idx = np.argmax(counts)
    mode_val = (edges[mode_idx] + edges[mode_idx+1]) / 2  # bin center
    plt.scatter([mode_val], [counts[mode_idx]], color='tomato', s=40, edgecolors='white', linewidth=0.6, zorder=5)
    plt.text(mode_val, counts[mode_idx]*1.01, f"mode={mode_val:.4f}", color='tomato', fontsize=8, ha='center', va='bottom')
    plt.xlabel(xlabel); plt.ylabel(ylabel); plt.title(title)
    plt.tight_layout(); plt.grid(True, linestyle='--', color='gray', alpha=0.5)
    plt.savefig(path, dpi=600); plt.close()


def save_curve_with_mean_std(y, path, title, xlabel, ylabel):
    y = np.asarray(y, dtype=np.float32)
    y_mean = float(np.mean(y))
    y_std = float(np.std(y))
    y_min, y_max = float(np.min(y)), float(np.max(y))
    max_x = len(y) - 1
    max_y = y[-1]
    plt.figure(figsize=(6, 4)); ax = plt.gca()
    ax.plot(y, color='steelblue', linewidth=2, label='episode mean MSE')
    ax.set_xlabel(xlabel); ax.set_ylabel(ylabel); ax.set_title(title)
    # Vertical line & marker for last point (max x)
    ax.plot([max_x, max_x], [y_min, max_y], color='gray', linestyle=':', linewidth=1, alpha=0.7)
    ax.scatter([max_x], [max_y], color='steelblue', s=25, edgecolors='white', linewidth=0.6, zorder=3)
    ax.text(max_x, y_min - 0.02*(y_max - y_min), f"{max_x}", ha='center', va='top', fontsize=8, color='dimgray')
    # Mean line
    ax.axhline(y_mean, color='tomato', linestyle='--', linewidth=1.5, alpha=0.9, label=f'mean = {y_mean:.4f}')
    # Ensure ylim covers mean
    pad = 0.05*(y_max - y_min + 1e-8)
    ax.set_ylim(min(y_min, y_mean) - pad, max(y_max, y_mean) + pad)
    # Legend + std text
    leg = ax.legend(fontsize=8, frameon=False)
    ax.text(0.08, 0.86, f"std = {y_std:.4f}", transform=ax.transAxes, fontsize=8, va='top', ha='left')
    ax.grid(True, linestyle='--', alpha=0.5)
    plt.tight_layout(); plt.savefig(path, dpi=600, bbox_inches='tight'); plt.close()


def save_quantile_curve(y, path, title, xlabel, ylabel):
    """Save quantile curve to file."""
    y = np.asarray(y, dtype=np.float32); n = len(y)
    x = np.linspace(0, 100, n)
    mid = n // 2; x_med = float(x[mid]); y_med = float(np.median(y))
    plt.figure(figsize=(6, 4)); ax = plt.gca()
    ax.plot(x, y, label='quantile')
    # median point
    ax.scatter([x_med], [y_med], s=35, color='tomato',
               edgecolors='white', linewidth=0.6, zorder=4)
    # axis limits
    y_min, y_max = float(np.min(y)), float(np.max(y))
    pad = 0.05 * (y_max - y_min + 1e-8)
    ax.set_ylim(y_min - pad, y_max + pad)
    ax.set_xlim(x[0], x[-1])
    # dashed helper lines (capture handle)
    x0, _ = ax.get_xlim()
    y0, _ = ax.get_ylim()
    hline, = ax.plot([x0, x_med], [y_med, y_med], color='tomato', linestyle='--', linewidth=1.2, alpha=0.9)
    ax.plot([x_med, x_med], [y0, y_med], color='tomato', linestyle='--', linewidth=1.2, alpha=0.9)
    ax.set_xlabel(xlabel); ax.set_ylabel(ylabel); ax.set_title(title)
    ax.legend([hline], [f'median = {y_med:.4f}'], fontsize=8, frameon=False)
    plt.tight_layout(); plt.grid(True); plt.grid(True, linestyle='--', color='gray', alpha=0.5)
    plt.savefig(path, dpi=600); plt.close()


def load_config_from_h5(h5_path: str) -> dict:
    with h5py.File(h5_path, "r") as f:
        config = {}
        if 'config' not in f:
            print("Warning: 'config' group not found in H5 file")
            return config
        config_group = f['config']
        for key in config_group.attrs:
            value = config_group.attrs[key]
            if isinstance(value, (np.ndarray, list)):
                if key == 'use_arms' and len(value) > 0:
                    config[key] = [bool(x) for x in value]
                else:
                    config[key] = value.tolist() if hasattr(value, 'tolist') else list(value)
            elif isinstance(value, (np.int64, np.int32, np.float64)):
                config[key] = value.item()
            else:
                config[key] = value
        return config


def main():
    """Main visualization pipeline for evaluation H5 files."""
    args = parse_args()
    h5_path = Path(args.h5_path)
    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    # Load episode-level summary statistics
    with h5py.File(h5_path, "r") as f:
        summary = f["episode_mse_summary"]
        episode_idx = summary["episode_idx"][:]
        mean_mse = summary["mean"][:]

    # Generate episode-level statistical visualizations
    save_hist(mean_mse, out_dir / "episode_mean_mse_hist.png",
              title="Episode-level Mean Action MSE Distribution",
              xlabel="Mean Action MSE", ylabel="Count")

    # Sort episodes by MSE (worst to best) and plot sorted curve
    order = np.argsort(mean_mse)[::-1]
    save_quantile_curve(mean_mse[order], out_dir / "episode_mean_mse_upper_quantile.png",
                        title="Upper Quantile Analysis of Episode MSE\n(Lower Percentile = Better Performance)",
                        xlabel="Upper Quantile Percentile (%)", ylabel="Mean Action MSE")

    save_curve_with_mean_std(mean_mse, out_dir / "episode_mean_mses.png", title="Episodes Mean MSE",
                              xlabel="Episode Index", ylabel="Mean Action MSE")

    print("Finished episode-level visualizations.")
    # Select top-K worst episodes for detailed visualization
    top_k = min(args.top_k, len(order))
    worst_eps = episode_idx[order[:top_k]]

    # resample_ratio = 3
    resample_ratio = load_config_from_h5(h5_path).get('resample_ratio', 1)
    with h5py.File(h5_path, "r") as f:
        for ep in tqdm(worst_eps, desc="Processing episodes", dynamic_ncols=True):
            ep_name = f"episode_{ep:06d}"; grp = f[ep_name]
            joint_names = [n.decode() if isinstance(n, bytes) else str(n) for n in grp["action_joint_names"][:]]

            step_mse = grp["action_mse"][:]; pred = grp["action"][:]; gt = grp["gt_action"][:]
            ep_mse = float(step_mse.mean()); ep_tag = f"mse_{ep_mse:.6f}_episode_{ep:06d}"
            T, H, D = pred.shape
            max_time = int(np.ceil(T / 50) * 50)
            T_cut = min(T, max_time)
            step_mse, pred, gt = step_mse[:T_cut], pred[:T_cut], gt[:T_cut]

            t_step = np.arange(T_cut); t_chunk = np.arange(H)
            mse_nz = step_mse[step_mse > 0]; mse_ylim = max(np.percentile(mse_nz, 95) * 1.1, 0.01) if len(mse_nz) else 0.01

            fig, axes = plt.subplots(D, 1, figsize=(14, max(6 * D, 14)), sharex=True, gridspec_kw=dict(hspace=0.08))
            axes = axes if D > 1 else [axes]
            colors = plt.cm.tab10(np.linspace(0, 1, max(D, 10)))

            for d, ax in enumerate(axes):
                base_c = colors[d][:3]
                segments, seg_colors = [], []
                for i in range(0, T_cut, args.chunk_stride):
                    y = pred[i, :, d]
                    actual_times = np.arange(H) * resample_ratio + i
                    frac = np.linspace(0, 1, H - 1) ** 0.8
                    for k in range(H - 1):
                        segments.append([[actual_times[k], y[k]], [actual_times[k + 1], y[k + 1]]])
                        seg_colors.append(base_c * (1 - frac[k]) + frac[k])
                if segments:
                    lc = LineCollection(segments, colors=seg_colors, linewidths=[1.5 - 1.2*f for f in frac]*((T_cut-1)//args.chunk_stride + 1))
                    ax.add_collection(lc)

                ax.plot(t_step, gt[:, d], color="black", linewidth=2)
                ax.set_ylabel(joint_names[d], fontsize=12); ax.grid(True, linewidth=0.3, alpha=0.5)

                ax2 = ax.twinx()
                ax2.fill_between(t_step, step_mse, 0, color='red', alpha=0.12)

                if d == 0:
                    ax.set_title(f"{ep_name} Action Chunks (stride={args.chunk_stride}) with GT + MSE", fontsize=15, pad=3)
                    ax.legend(handles=[
                        Line2D([0], [0], color=base_c, lw=1.5, label="Predicted Chunks"),
                        Line2D([0], [0], color="black", lw=2, label="Ground Truth"),
                        Patch(facecolor="red", alpha=0.12, label="Action MSE")
                    ], loc="upper right", fontsize=9, frameon=True)

            tick_spacing = 20 if max_time <= 100 else 40 if max_time <= 200 else 100 if max_time <= 500 else 200
            x_ticks = np.unique(np.append(np.arange(0, max_time + 1, tick_spacing), max_time))
            for ax in axes: ax.set_xlim(0, max_time); ax.set_xticks(x_ticks); ax.tick_params(axis="x", labelsize=9)
            axes[-1].set_xlabel("Step", fontsize=12)
            fig.subplots_adjust(top=0.97, bottom=0.12, left=0.08, right=0.92)
            fig.savefig(out_dir / f"{ep_tag}_all_joints_full_chunk.png", dpi=200, bbox_inches="tight")
            plt.close(fig)

    print(f"[Done] Visualization results saved to: {out_dir.resolve()}")


if __name__ == "__main__":
    main()
